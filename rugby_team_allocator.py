# -*- coding: utf-8 -*-
"""Rugby Team Allocator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uULXXPVzIJftkOZOWJDJKftC5ngjh3os
"""

import pandas as pd
import gspread
from google.oauth2.service_account import Credentials
from collections import defaultdict
import math

# --- CONFIGURATION ---
# --- Google Sheets Configuration ---
GSHEET_ID = '1uDXAknETFeFvhowST2W85rJbwzf_ND04miXcTkZplX8'
SOURCE_WORKSHEET_NAME = 'Team_sheet'
OUTPUT_WORKSHEET_NAME = '1st_Sort_Output_v2'

# --- Team Allocation Rules ---
MIN_TEAM_SIZE = 7
MAX_TEAM_SIZE = 9
IDEAL_TEAM_SIZE = 8

# --- Coach Pairing Configuration ---
COACH_PAIRINGS = [
    # ('Coach A', 'Coach B'),
]


def setup_gspread_client():
    """Authenticates with Google Sheets API using service account credentials."""
    try:
        scope = [
            "https://www.googleapis.com/auth/spreadsheets",
            "https://www.googleapis.com/auth/drive.file"
        ]
        creds = Credentials.from_service_account_file('credentials.json', scopes=scope)
        client = gspread.authorize(creds)
        return client
    except FileNotFoundError:
        print("Error: 'credentials.json' not found. Please follow the setup instructions in the script.")
        return None
    except Exception as e:
        print(f"An error occurred during Google Sheets authentication: {e}")
        return None

def preprocess_data(df):
    """Cleans and prepares player data, ensuring all required columns exist."""
    df.columns = [str(col).strip().lower().replace(' ', '_') for col in df.columns]
    required_cols = {
        'key': '', 'available': 0, 'istentpole': False,
        'pairedwith': '', 'tier': 2, 'coach': '', 'pod': 'Unknown'
    }
    for col, default_val in required_cols.items():
        if col not in df.columns:
            print(f"Warning: Column '{col}' not found. Creating it with default values.")
            df[col] = default_val

    df.fillna({
        'key': '', 'available': 0, 'istentpole': False,
        'pairedwith': '', 'tier': 2, 'coach': '', 'pod': 'Unknown'
    }, inplace=True)

    df['key'] = df['key'].astype(str).str.strip()
    df = df[df['key'] != ''].copy()
    df['available'] = pd.to_numeric(df['available'], errors='coerce').fillna(0).astype(int)
    available_players_df = df[df['available'] == 1].copy()

    available_players_df['istentpole'] = available_players_df['istentpole'].apply(
        lambda x: str(x).strip().upper() == 'TRUE'
    )
    available_players_df['pairedwith'] = available_players_df['pairedwith'].astype(str).str.strip()
    available_players_df['coach'] = available_players_df['coach'].astype(str).str.strip()
    available_players_df['tier'] = pd.to_numeric(available_players_df['tier'], errors='coerce').fillna(2).astype(int)
    available_players_df['pod'] = available_players_df['pod'].astype(str).str.strip()

    return df, available_players_df

# Corresponds to "Phase 0: The Group Strategy"
def create_allocation_groups(df):
    """Identifies social/coach pairings and creates allocation groups with aggregated attributes."""
    parent = {key: key for key in df['key']}
    def find(key):
        if parent[key] == key: return key
        parent[key] = find(parent[key])
        return parent[key]
    def union(key1, key2):
        root1, root2 = find(key1), find(key2)
        if root1 != root2: parent[root2] = root1

    key_map = {name.lower(): key for name, key in zip(df['key'], df['key'])}
    for _, row in df.iterrows():
        if row['pairedwith']:
            partner_key = key_map.get(str(row['pairedwith']).lower())
            if partner_key and partner_key in parent:
                union(row['key'], partner_key)

    coach_to_kids = defaultdict(list)
    for _, row in df.iterrows():
        if row['coach']:
            coach_to_kids[row['coach']].append(row['key'])
    for coach1, coach2 in COACH_PAIRINGS:
        kids1, kids2 = coach_to_kids.get(coach1), coach_to_kids.get(coach2)
        if kids1 and kids2:
            anchor = kids1[0]
            for kid in kids1[1:] + kids2:
                union(anchor, kid)

    social_groups = defaultdict(list)
    for key in df['key']:
        social_groups[find(key)].append(key)

    player_info = df.set_index('key')
    groups = []
    for player_keys in social_groups.values():
        group_pods = player_info.loc[player_keys]['pod']
        composition = group_pods.value_counts().to_dict()

        # Determine the primary color of the group for initial placement
        primary_pod = group_pods.mode()[0] if not group_pods.empty else 'Unknown'

        groups.append({
            'keys': player_keys,
            'size': len(player_keys),
            'is_tentpole_group': any(player_info.loc[key]['istentpole'] for key in player_keys),
            'composition': composition,
            'primary_pod': primary_pod,
            'has_green': 'Green' in composition
        })
    return groups

def allocate_teams_stratified(groups, df_available):
    """Performs the new, constraint-aware preferential assignment of groups to teams."""
    assignments = {}

    # --- Phase 1 & 2: Foundation and Depth ---
    # Determine team structure
    red_players = sum(g['composition'].get('Red', 0) for g in groups)
    blue_players = sum(g['composition'].get('Blue', 0) for g in groups)
    num_red_teams = math.ceil(red_players / IDEAL_TEAM_SIZE) if red_players > 0 else 0
    num_blue_teams = math.ceil(blue_players / IDEAL_TEAM_SIZE) if blue_players > 0 else 0

    teams = {}
    for i in range(num_red_teams): teams[f"Red Team {i+1}"] = {'color': 'Red'}
    for i in range(num_blue_teams): teams[f"Blue Team {i+1}"] = {'color': 'Blue'}

    # Initialize team stats
    for name in teams:
        teams[name].update({'size': 0, 'red_count': 0, 'green_count': 0, 'pink_count': 0, 'groups': []})

    # Assign core Red/Blue groups
    unassigned_groups = []
    red_blue_groups = sorted([g for g in groups if g['primary_pod'] in ['Red', 'Blue']], key=lambda x: -x['size'])

    for group in red_blue_groups:
        target_color = group['primary_pod']
        potential_teams = [name for name, stats in teams.items() if stats['color'] == target_color and stats['size'] + group['size'] <= MAX_TEAM_SIZE]

        if potential_teams:
            best_team = min(potential_teams, key=lambda name: teams[name]['size'])
            teams[best_team]['size'] += group['size']
            teams[best_team]['groups'].append(group)
            for key in group['keys']: assignments[key] = best_team
        else:
            unassigned_groups.append(group)

    # --- Phase 3: Strategic Filler Distribution ---
    filler_groups = unassigned_groups + [g for g in groups if g['primary_pod'] not in ['Red', 'Blue']]

    # Update team stats after initial placement
    for name, stats in teams.items():
        stats['red_count'] = sum(g['composition'].get('Red', 0) for g in stats['groups'])
        stats['green_count'] = sum(g['composition'].get('Green', 0) for g in stats['groups'])
        stats['pink_count'] = sum(g['composition'].get('Pink', 0) for g in stats['groups'])

    # Stage 3A: Targeted Green Distribution
    green_groups = sorted([g for g in filler_groups if g['has_green']], key=lambda x: -x['size'])
    relaxation_pool = []

    for group in green_groups:
        group_green_count = group['composition'].get('Green', 0)
        potential_teams = []
        for name, stats in teams.items():
            # Hard Constraint Check
            if (stats['size'] + group['size'] <= MAX_TEAM_SIZE) and \
               (stats['green_count'] + group_green_count <= 4):
                potential_teams.append(name)

        if potential_teams:
            # Preference Ranking
            best_team = sorted(potential_teams, key=lambda name: (-teams[name]['red_count'], teams[name]['size']))[0]
            # Assign and update
            teams[best_team]['size'] += group['size']
            teams[best_team]['green_count'] += group_green_count
            teams[best_team]['red_count'] += group['composition'].get('Red', 0)
            for key in group['keys']: assignments[key] = best_team
        else:
            relaxation_pool.append(group)

    # Stage 3B: Constraint Relaxation
    for group in sorted(relaxation_pool, key=lambda x: -x['size']):
        group_green_count = group['composition'].get('Green', 0)
        potential_teams = [name for name, stats in teams.items() if stats['size'] + group['size'] <= MAX_TEAM_SIZE]

        if potential_teams:
            # Minimization Ranking
            best_team = sorted(potential_teams, key=lambda name: (teams[name]['green_count'], -teams[name]['red_count'], teams[name]['size']))[0]
            teams[best_team]['size'] += group['size']
            teams[best_team]['green_count'] += group_green_count
            teams[best_team]['red_count'] += group['composition'].get('Red', 0)
            for key in group['keys']: assignments[key] = best_team
            print(f"Warning: Tenure constraint violated. Assigned group {group['keys']} to {best_team}, which now has {teams[best_team]['green_count']} green players.")
        else:
             print(f"Error: Could not place group {group['keys']} even after relaxing constraints.")

    # Stage 3C: Remaining Filler Distribution
    remaining_fillers = [g for g in filler_groups if not g['has_green'] and all(k not in assignments for k in g['keys'])]
    for group in sorted(remaining_fillers, key=lambda x: -x['size']):
        potential_teams = [name for name, stats in teams.items() if stats['size'] + group['size'] <= MAX_TEAM_SIZE]
        if potential_teams:
            # Preference Ranking
            best_team = sorted(potential_teams, key=lambda name: (teams[name]['pink_count'], teams[name]['size'], teams[name]['color'] != 'Red'))[0]
            teams[best_team]['size'] += group['size']
            teams[best_team]['pink_count'] += group['composition'].get('Pink', 0)
            for key in group['keys']: assignments[key] = best_team
        else:
            print(f"Error: Could not place remaining filler group {group['keys']}.")

    return assignments

def main():
    """Main function to run the revised team allocation script."""
    client = setup_gspread_client()
    if not client: return

    try:
        spreadsheet = client.open_by_key(GSHEET_ID)
        worksheet = spreadsheet.worksheet(SOURCE_WORKSHEET_NAME)
        data = worksheet.get_all_records()
        df_original = pd.DataFrame(data)
        print(f"Successfully loaded {len(df_original)} players from Google Sheet.")
    except Exception as e:
        print(f"An error occurred while reading the Google Sheet: {e}")
        return

    df_all_players, df_available = preprocess_data(df_original.copy())
    if df_available.empty:
        print("No available players to sort.")
        return

    print(f"Processing {len(df_available)} available players.")

    # Phase 0: Create Groups
    allocation_groups = create_allocation_groups(df_available)

    # New Allocation Logic
    assignments = allocate_teams_stratified(allocation_groups, df_available)

    df_all_players['suggested_assignment'] = df_all_players['key'].map(assignments).fillna('Not Assigned')

    try:
        try:
            output_worksheet = spreadsheet.worksheet(OUTPUT_WORKSHEET_NAME)
            output_worksheet.clear()
        except gspread.exceptions.WorksheetNotFound:
            output_worksheet = spreadsheet.add_worksheet(title=OUTPUT_WORKSHEET_NAME, rows="100", cols="20")

        output_data = [df_all_players.columns.values.tolist()] + df_all_players.values.tolist()
        output_worksheet.update('A1', output_data, value_input_option='USER_ENTERED')

        print(f"\nProcess complete. Allocation saved to tab '{OUTPUT_WORKSHEET_NAME}'.")
    except Exception as e:
        print(f"An error occurred while writing to the Google Sheet: {e}")

if __name__ == '__main__':
    main()

